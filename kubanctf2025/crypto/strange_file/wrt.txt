CSC CTF — Writeup: «Странный файл»

Автор решения: ChatGPT
Финальный флаг: CSC{h2l10_Crypt0_bR0}

------------------------------------------------------------
Краткая идея
------------------------------------------------------------
Внутри zip-архива был слой за слоем:
AES → Morse → Base32 → (сообщение + огромный Base64) → поток «токенов»
→ биты → ASCII-hex → итоговый флаг.

------------------------------------------------------------
Дано
------------------------------------------------------------
Файл: strange_file.zip
  └─ внутри бинарь «strange_file» с подсказками:
     • длинная hex-строка — это AES-шифртекст
     • даны ключ и IV
     • встречается фраза “Veni, vidi, vici.” и ремарка про Caesar/AES
     • огромный Base32/64 и ASCII-art (после декодирования)

------------------------------------------------------------
Шаг 1. Расшифровка AES-128-CBC (без паддинга)
------------------------------------------------------------
Из «strange_file» извлекаем три вещи:
  - CIPHER (большая непрерывная hex-строка)
  - KEY  = 12bcaf93ff0012cc99abcdef03941325
  - IV   = cc03941325caf93f12b012f099abcdef

Команда (OpenSSL):
  openssl enc -d -aes-128-cbc \
    -K 12bcaf93ff0012cc99abcdef03941325 \
    -iv cc03941325caf93f12b012f099abcdef \
    -nopad -in cipher.bin -out plain1_nopad.bin

На выходе — текст из точек/тире (Morse).

------------------------------------------------------------
Шаг 2. Морзе → буквы/цифры
------------------------------------------------------------
Фильтруем символы: только '.', '-' и пробелы/переводы строк.
Разбираем по стандартной таблице Морзе (A–Z, 0–9).
Получаем длинную буквенно-цифровую строку; внутри — большой блок base32.

------------------------------------------------------------
Шаг 3. Base32 → «Veni, vidi, vici.» + Base64-блок
------------------------------------------------------------
Декод base32 даёт текст вида:
  "Veni, vidi, vici.\n\n" + огромный Base64-блок + хвост с ASCII-art.
ASCII-art выводит Почуиту (Pochita) и надпись от автора:
  “Keep Pochita. By the way, the task has a Caesar cipher and an AES cipher ;)”
Caesar тут — скорее тема/намёк (Юлий Цезарь), дальше он не понадобился.

------------------------------------------------------------
Шаг 4. Base64 → необычный поток «троек»
------------------------------------------------------------
Декод Base64 даёт массив байт с чётким паттерном: (b1, b2, 0xE3) повторяется.
Встречается ровно 6 уникальных пар (b1,b2). Т.е. каждая тройка — «символ» из 6-значного алфавита.
Дополнительно есть третий тип тройки, который играет роль разделителя.

Наблюдение по индексам (после нормализации):
  • (5,1,0)  → «ноль»/бит 0
  • (5,2,0)  → «единица»/бит 1
  • (4,3,0)  → разделитель (flush/сброс накопленных бит в байты)

------------------------------------------------------------
Шаг 5. Токены → биты → байты → ASCII-hex
------------------------------------------------------------
Алгоритм:
  1) Пройти массив троек; конвертировать (5,1,0) в 0, (5,2,0) в 1.
  2) При встрече (4,3,0) — сгрупповать накопленные биты по 8 и выдать байты.
  3) На печатаемых байтах получается строка из символов 0–9a–f (ASCII-hex),
     местами с пробелами.

Хвост был обрезан на один полубайт (последний байт «7» вместо «7d»):
  дополняем последнюю «половинку» как 'd', чтобы получить корректный последний байт.

------------------------------------------------------------
Шаг 6. Декод ASCII-hex → флаг
------------------------------------------------------------
Убираем пробелы, декодируем из hex в байты → UTF-8 строка:
  CSC{h2l10_Crypt0_bR0}

------------------------------------------------------------
Воспроизводимый код (Python, кратко)
------------------------------------------------------------
Ниже минимальный каркас для последних этапов (после Base64):

```python
import base64

# b64_blob = содержимое большого Base64 после "Veni, vidi, vici.\n\n"
raw = base64.b64decode(b64_blob)

# взять только полные тройки:
raw = raw[:(len(raw)//3)*3]
triples = [raw[i:i+3] for i in range(0, len(raw), 3)]

# Нормализация: сузим до 6 уникальных (b1,b2), а 3-й байт у всех 0xE3.
pairs = [(t[0], t[1]) for t in triples]
uniq  = sorted(set(pairs))
idx   = [uniq.index(p) for p in pairs]  # 0..5 последовательность «символов»

# Преобразуем каждые 3 индекса в «токен-тройку»
tok = [tuple(idx[i:i+3]) for i in range(0, len(idx), 3)]

ZERO = (5,1,0)
ONE  = (5,2,0)
SEP  = (4,3,0)

bits = []
out  = bytearray()
for t in tok:
    if t == ZERO:
        bits.append(0)
    elif t == ONE:
        bits.append(1)
    elif t == SEP:
        # flush 8-битные байты
        for i in range(0, len(bits)//8*8, 8):
            b=0
            for j in range(8):
                b = (b<<1) | bits[i+j]
            out.append(b)
        bits.clear()

# финальный сброс (если нужно)
for i in range(0, len(bits)//8*8, 8):
    b=0
    for j in range(8):
        b = (b<<1) | bits[i+j]
    out.append(b)

ascii_hex = ''.join(chr(b) for b in out if 32 <= b <= 126).replace(' ', '')
if ascii_hex.endswith('7'):
    ascii_hex += 'd'  # дополняем последний полубайт

flag = bytes.fromhex(ascii_hex).decode()
print(flag)  # => CSC{h2l10_Crypt0_bR0}
```

------------------------------------------------------------
Примечания/проверки
------------------------------------------------------------
• AES-режим: важен именно CBC и «-nopad». С другими режимами/паддингом текст ломается.
• Base32 иногда требует ручного дополнения '=' до длины % 8 == 0.
• В Base64-блоке есть «шум» (переводы строк и не-базовые символы в хвосте) —
  лучше фильтровать по алфавиту Base64.
• Токенизация работает только при верном порядке: биты идут пачками
  и разделяются специальной тройкой (4,3,0). Если смешать порядок — получится «белый шум».

Удачи и да пребудет с вами Почуита :)
