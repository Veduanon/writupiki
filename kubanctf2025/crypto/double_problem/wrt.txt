Двойная проблема — writeup (RU)
Уровень: Средний

Задача
------
В архиве даны:
- `public1.txt` — модуль n₁ и экспонента e
- `public2.txt` — модуль n₂ и экспонента e
- `flag.enc` — зашифрованный флаг (целое число)

Нужно восстановить флаг.

Идея решения
------------
Если два RSA-модуля n₁ и n₂ имеют **общий простой множитель** p, то:
- p = gcd(n₁, n₂) > 1
- q₁ = n₁ / p, q₂ = n₂ / p
- φ(n₁) = (p−1)(q₁−1), φ(n₂) = (p−1)(q₂−1)
- приватные экспоненты: d₁ = e⁻¹ mod φ(n₁), d₂ = e⁻¹ mod φ(n₂)
- расшифровка: m₁ = c^{d₁} mod n₁ (или m₂ = c^{d₂} mod n₂)

То есть одна уязвимость (общий множитель) ломает оба ключа. Такой приём называется **Common Prime / GCD-атака**.

Разбор артефактов
-----------------
Из файлов:
- e₁ = e₂ = 65537
- n₁ — 1023 бита, n₂ — 1024 бита
- gcd(n₁, n₂) дал 512-битное число p ⇒ общий простой действительно есть

Дальше факторизуем:
- p найден, q₁ = n₁ / p, q₂ = n₂ / p
- d₁ = e⁻¹ mod (p−1)(q₁−1), d₂ аналогично

После расшифровки `flag.enc` под одним из модулей получаем байтовое представление, заполненное ведущими нулями (без PKCS#1 v1.5). Достаточно отбросить нули слева и интерпретировать как UTF‑8.

Код (Python 3)
--------------
```python
from math import gcd
from sympy import mod_inverse

def read_pub(path):
    with open(path,'r') as f:
        lines = [line.strip() for line in f if line.strip()]
    n = int(lines[0]); e = int(lines[1])
    return n, e

# Ввод
n1, e1 = read_pub("public1.txt")
n2, e2 = read_pub("public2.txt")
c = int(open("flag.enc","r").read().strip())

# 1) Общий множитель
p = gcd(n1, n2)
assert p != 1, "Модули взаимно просты — этот подход не сработает"
q1, q2 = n1 // p, n2 // p

# 2) Приватные ключи
phi1 = (p-1)*(q1-1)
phi2 = (p-1)*(q2-1)
d1 = mod_inverse(e1, phi1)
d2 = mod_inverse(e2, phi2)

# 3) Расшифровка (пробуем оба на всякий случай)
m1 = pow(c, d1, n1)
m2 = pow(c, d2, n2)

# 4) Вытаскиваем строку (срезаем ведущие нули)
def int_to_clean_bytes(m, n_mod):
    k = (n_mod.bit_length()+7)//8
    b = m.to_bytes(k, 'big')
    return b.lstrip(b'\x00')

msg = None
for m,n in [(m1,n1),(m2,n2)]:
    b = int_to_clean_bytes(m, n)
    try:
        msg = b.decode('utf-8')
        break
    except UnicodeDecodeError:
        continue

print(msg)
```

Вывод/пояснения
---------------
- В задаче `msg` декодируется в осмысленный текст сразу (без PKCS#1‑паддинга), т.к. сообщение короткое, а при шифровании его представили просто как число и заполнили ведущими нулями.
- Полученная строка: `CSC{rs4_gcd_w0rk3d_n1c3}`

Ответ
-----
**Флаг: `CSC{rs4_gcd_w0rk3d_n1c3}`**

Что важно запомнить
-------------------
- Повторное использование одного и того же простого p в разных модулях нередко возникает из‑за плохого ГПСЧ при генерации ключей.
- Простейшая проверка безопасности ключей: считать gcd между новыми n и известной коллекцией уже выпущенных модулей.
- Если gcd(n₁, n₂) > 1, оба ключа мгновенно компрометируются.
 