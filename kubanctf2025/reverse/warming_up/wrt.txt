[CTF] Reverse: XOR + little-endian сравнение (длина 23)

ЗАДАЧА
------
Дан декомпилированный main(). Программа:
1) читает строку,
2) проверяет, что длина == 23,
3) поочерёдно XOR’ит каждый символ с ключом K (зависит от индекса),
4) сравнивает результат с константным байтовым массивом в памяти (v8),
5) печатает "успех" при полном совпадении.

ФРАГМЕНТ ЛОГИКИ
---------------
if (std::string::size(v11) == 23) {
    v8[0] = 0x064251664F776777;
    v8[1] = 0x2260366B6B714746;
    v8[2] = 0x002D24221024230F;   // фактически 0x2D24221024230F, старший байт нулевой
    for (i = 0; i <= 22; ++i) {
        K = (i > 12) ? 0x50 : 0x34;
        v7[i] = input[i] ^ K;
    }
    // далее сравнение v7[0..22] с первыми 23 байтами ((uint8_t*)v8)[0..22]
}

КЛЮЧЕВОЕ
--------
1) Ключ XOR зависит от позиции:
   - для i = 0..12: K = 0x34 ('4')
   - для i = 13..22: K = 0x50 ('P')

2) Сравнение идёт побайтно с ((uint8_t*)v8)[j], то есть в представлении little-endian.
   Это значит, что из 64-битных слов v8[0..2] байты берутся от младшего к старшему.

ИЗВЛЕЧЕНИЕ ЦЕЛЕВЫХ БАЙТ (LE)
----------------------------
Разворачиваем 64-битные константы в порядке little-endian и берём первые 23 байта:
v8[0] = 0x064251664F776777  ->  [77, 67, 77, 4F, 66, 51, 42, 06]
v8[1] = 0x2260366B6B714746  ->  [46, 47, 71, 6B, 6B, 36, 60, 22]
v8[2] = 0x002D24221024230F  ->  [0F, 23, 24, 10, 22, 24, 2D, 00]

Первые 23 байта (в hex) и индексы:
i= 0: 77  i= 1: 67  i= 2: 77  i= 3: 4F  i= 4: 66  i= 5: 51  i= 6: 42  i= 7: 06
i= 8: 46  i= 9: 47  i=10: 71  i=11: 6B  i=12: 6B  i=13: 36  i=14: 60  i=15: 22
i=16: 0F  i=17: 23  i=18: 24  i=19: 10  i=20: 22  i=21: 24  i=22: 2D
(байт 23-й из v8[2] = 00 — НЕ используется, т.к. берём только 0..22)

ОБРАТНОЕ ПРЕОБРАЗОВАНИЕ
------------------------
input[i] = v8_le[i] ^ K,
где K = 0x34 для i ∈ [0..12], и K = 0x50 для i ∈ [13..22].

Проверка первых символов:
0: 0x77 ^ 0x34 = 0x43 = 'C'
1: 0x67 ^ 0x34 = 0x53 = 'S'
2: 0x77 ^ 0x34 = 0x43 = 'C'
3: 0x4F ^ 0x34 = 0x7B = '{'
...
Дальше аналогично.

СКРИПТ ДЛЯ ВОССТАНОВЛЕНИЯ
-------------------------
Python (печатает флаг):

    v8_le = [
        0x77,0x67,0x77,0x4F,0x66,0x51,0x42,0x06,
        0x46,0x47,0x71,0x6B,0x6B,0x36,0x60,0x22,
        0x0F,0x23,0x24,0x10,0x22,0x24,0x2D
    ]
    flag_bytes = []
    for i,b in enumerate(v8_le):
        k = 0x50 if i > 12 else 0x34
        flag_bytes.append(b ^ k)
    print(bytes(flag_bytes).decode('ascii'))

РЕЗУЛЬТАТ
---------
CSC{Rev2rsE__f0r_st@rt}

ПРИМЕЧАНИЯ/ПОДВОДНЫЕ КАМНИ
--------------------------
- Важно учесть little-endian при разборе 64-битных констант.
- Условие "i > 12" (а не >=) — ключ меняется, начиная с позиции 13.
- Строгая проверка длины: вход должен быть ровно 23 символа.
